


Day 2: Day 2:data structures: Searching and Sorting and tree
____________________________________________________________
1. Counting sort, insertion sort, bubble sort. 
2. Heap sort 
3. Quick sort merge sort. 
4. Search element: unordered array, ordered array, Heap.	

Trees	
1. Different representation of trees. 
2. Tree basic operations: Create tree, insert node, delete node etc. 
3. Different traversal of trees: in-order, pre-order, post-order, level-order. 
4. Introduction to binary search tree a. Create, insert new node in binary search tree b. Search in BST. 
5. Example of balanced binary tree: AVL, RB etc

Graphs	
1. Different representation of graph
2. BFS, DFS, Topological sort.
3. Importance and Applications of graph: Single source shortest path, All pair shortest path


  
Recursion:
_____________
public class Factorial {
	static int factorial(int n) {
		if (n == 0)
			return 1;
		else
			return (n * factorial(n - 1));
	}

	public static void main(String args[]) {
		int i, fact = 1;
		int number = 4;
		fact = factorial(number);
		System.out.println("Factorial of " + number + " is: " + fact);
	}
}	

linear search:
_____________

public class LinearSearch {

	public static void main(String[] args) {
		int arr[]= {3,5,6,-3,78,22};
		int pos=-1;
		int val=60;
		boolean isFound=false;
		for(int i=0;i<arr.length; i++) {
			if(arr[i]==val) {
				isFound=true;
				pos=i;
				break;
			}
		}
		if(isFound)
			System.out.println("found: "+ pos);
		else
			System.out.println("not found");
	}
}




binary search:
________________



public class DemoBS {

	public static void main(String[] args) {
		int arr[]= {3,5,6,-3,78,22};
		int first,last, mid;
		first=0;
		last=arr.length-1;
		 mid = (first + last) / 2;
		 int key=78;
		 
		while (first <= last) {
			if (arr[mid] < key) {
				first = mid + 1;
			} else if (arr[mid] == key) {
				System.out.println("Element is found at index: " + mid);
				break;
			} else {
				last = mid - 1;
			}
			mid = (first + last) / 2;
		}
		if (first > last) {
			System.out.println("Element is not found!");
		}
	}
}






Bubble sort:
______________

int a[]= {38,52,9,18, 6,62,13};
		int temp;
		for(int i=0;i<a.length; i++)
		{
			for(int j=0;j<a.length-1; j++) 
			{
				if(a[j]> a[j+1]) 
				{
					temp=a[j];
					a[j]=a[j+1];
					a[j+1]=temp;
				}
			}
		}
		for(int val: a) {
			System.out.print(val+" ");
		}


Selection sort
________________
searh smallest and swap with current value

int a[]= {38,52,9,18, 6,62,13};
		int min;
		int temp;
		for(int i=0;i<a.length; i++)
		{
			min=i;
			for(int j=i+1;j<a.length; j++) 
			{
				if(a[j]<a[min]) 
					min=j;
			}
			temp=a[i];
			a[i]=a[min];
			a[min]=temp;
			
		}
		for(int val: a) {
			System.out.print(val+" ");
		}


insertion sort 
________________
put element to its corrrect position(card playing)

int a[]= {5,1,6,2,4,3};// playing card
		int temp;
		int j;
		for(int i=0;i<a.length; i++)
		{
			temp=a[i];
			j=i;
			while(j>0 && a[j-1]> temp)
			{
				a[j]=a[j-1];
				j=j-1;
			}
			a[j]=temp;
		}
		for(int val: a) {
			System.out.print(val+" ");
		}



MergeSort
__________

public class MergeSort 
{
	int array[];
	int tempMergeArr[];
	int lengh;

	public static void main(String[] args) 
	{
		int inputArr[] = { 48, 36, 13, 52, 19, 94, 21 };
		MergeSort mergeSort = new MergeSort();
		mergeSort.sort(inputArr);
		for(int val: inputArr) {
			System.out.print(val+" ");
		}
	}

	void sort(int[] inputArr) 
	{
		this.array = inputArr;
		this.lengh = inputArr.length;
		this.tempMergeArr = new int[lengh];
		divideArray(0, lengh - 1);
	}

	void divideArray(int lowerIndex, int higherIndex)
	{
		if (lowerIndex < higherIndex) 
		{
			int middle = lowerIndex + (higherIndex - lowerIndex) / 2;
			divideArray(lowerIndex, middle);// used for left side arr
			divideArray(middle + 1, higherIndex);// used for right side arr

			mergeArrary(lowerIndex, middle, higherIndex);

		}
	}

	void mergeArrary(int lowerIndex, int middle, int higherIndex) 
	{
			for(int i=lowerIndex; i<=higherIndex; i++)
			{
				tempMergeArr[i]=array[i];
			}
			
			int i=lowerIndex;
			int j=middle+1;
			int k=lowerIndex;
			
			while(i<=middle && j<=higherIndex)
			{
				if(tempMergeArr[i]<=tempMergeArr[j])
				{
					array[k]=tempMergeArr[i];
					i++;
				}
				else
				{
					array[k]=tempMergeArr[j];
					j++;
				}
				k++;
			}
	}
}

